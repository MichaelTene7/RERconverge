---
title: "RERconverge Analysis Walkthrough"
bibliography: RERConverge.bib
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  pdf_document:
    toc: yes
  html_document:
    css: custom.css
    toc: yes
authors: Maria Chikina
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```





\newpage

This walkthrough provides instructions for using the updated and faster RERconverge pipeline.

# Overview
There are some  important differences between the old and new versions

1. The calculations are broken into steps in a different way

2. The results  of the output are not exactly the same. One of the main calculations performed by RERconverge is turning evolutionary rates into relative rates by correcting for the expected evolutionary rate. The methods differ in how the expected rate is computed. The old method computes a different normalization vector for every gene/element using the set all other genes/elements that have all of the same species as a subset. This is quite time consuming but exactly recapitulates the calculation done in some of the original evolutionary rate correlation papers.  The new method computes a single normalization vector that is used for all elements. This may not sufficiently capture all of the relevant variation. To account for this we have included PC normalization as an option where the data can be normalized for any number of principle components thus affording the ability to capture and correct for more axes of variation. Extensive testing on datasets with  known ground truth showed that the normalization method matters relatively little.


3. The internal representation of the trees and paths are different. We are now using functions provided by `TreeTools` that greatly speed up some of the tree matching computations. However, the trees need to be in a different order. Thus, while you can use the objects generated by `readTrees2` in the old pipeline the reverse is not the case. You cannot feed objects generated by `readTrees` into the new pipeline as you will get an error.

### Comparing the old and new pipelines




In R, load the RERConverge library. 

```{r results='hide', message = FALSE, warning = FALSE, cache = TRUE}
library(RERconverge)

```
From the old tutorial we would perform these steps.

```{r results='hide', message = FALSE, warning = FALSE, cache = TRUE}
rerpath = find.package('RERconverge') #If this errors, there is an issue with installation
toytreefile = "subsetMammalGeneTrees.txt"
toyTrees=readTrees(paste(rerpath,"/extdata/",toytreefile,sep=""), max.read = 500)
data("logAdultWeightcm")
mamRERw = getAllResiduals(toyTrees,useSpecies=names(logAdultWeightcm),   transform = "sqrt", weighted = T, scale = T)
```

## Reading trees in the new pipeline

 We use `readTrees2` which has exactly the same elements in the output except that the trees and paths are ordered differently. It is also considerably faster.


```{r, cache = TRUE}
toyTreesNew=readTrees2(paste(rerpath,"/ext/",toytreefile,sep=""))
```


```{r, cache=FALSE}
map=mapIndex(toyTreesNew, toyTrees)
plot(toyTreesNew$paths[1:10,], toyTrees$paths[1:10, map])
```

## Transform the trees

The next step is to transform the treesObj. This transformation has the same purpose as the one in the old `getAllResiduals`. Imputing is optional but recommended as it allows for principle component normalization in the next step.
```{r, cache=FALSE}
toyTreesSq=transformPaths(toyTrees, transform = "sqrt", impute = T)
```


## Computing the residuals

The next step is to compute the residuals
```{r, cache=FALSE}
RERall = getAllResiduals2(toyTreesSq,useSpecies=names(logAdultWeightcm), n.pcs = 0)
```

To use PC normalization you can specify the number of PCs to use. Here is an example using 2 PCs.

```{r, cache=FALSE}
RERallPC2 = getAllResiduals2(toyTreesSq,useSpecies=names(logAdultWeightcm), n.pcs = 2.)
```

The `RERall` is not a matrix but is list object which contains a matrix called `allresiduals`. Unlike the previous `getAllResiduals` method these are all the residuals that can be in principle computed and not the maximal independent set that would be used for downstream analysis. Also, at this point no column-wise normalization (achieved with `scale` in the old function) has been performed.

## Extracting the RER matrix

This function performs column-wise normalization and extracts the maximally independent set. The "scale" normalization is default.

```{r, cache=FALSE}
rmat=getRMat(RERall, norm = "scale")
```



```{r, cache=FALSE}
rmatPC2=getRMat(RERallPC2, norm="scale")
```


## Comparing the results

Using the map above we can directly compare the results. The computed residuals are indeed correlated but different. This difference does not appear to be biologically important. In all of our test the biological signal with consistent between the old and new pipeline.

```{r, cache=FALSE}
par(mfrow=c(1,2))
plotWithCor(mamRERw[, map],rmat)
plotWithCor( mamRERw[, map],rmatPC2)
```


All of the other function work as before. We can make a tree plot by supplying the trees object `toyTreesNew` and the RER matrix `rmat`


```{r fig2, fig.height=9,fig.width=10, warning = FALSE, cache = TRUE, tidy = FALSE}
#plot RERs
par(mfrow=c(1,1))
phenvExample <- foreground2Paths(c("Vole","Squirrel"),toyTreesNew,clade="terminal")
plotRers(rmat,"BEND3",phenv=phenvExample) #plot RERs
```

```{r fig2b, fig.height=9,fig.width=10, warning = FALSE, cache = TRUE, tidy = FALSE}
#plot RERs as tree
par(mfrow=c(1,1))
bend3rers = returnRersAsTree(toyTreesNew, rmat, "BEND3", plot = TRUE,
                             phenv=phenvExample) #plot RERs
```
